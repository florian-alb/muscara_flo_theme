const addToCartForms = document.querySelector("#addBundle"); addToCartForms.addEventListener("click", async (event) => {
event.preventDefault();

// pourquoi pas le faire en dehors de cette fonction et pourquoi pas le faire premiÃ¨rement quand le DOM charge et quand
le form est update pour avoir l'id de la variante en temps rÃ©el.

// Collects product data at the time of click to ensure that it is up to date. const productData = collectProductData();
console.log("ğŸš€ ~ productData:", productData);

try { // Match product variants and wait for completion. const addedVariants = await matchProductsVariants(productData);
console.log("ğŸš€ ~ added_variants:", addedVariants);

// Prepare objects for API cart/add.js, each variant with quantity = 1. const itemsToAdd = addedVariants.map(id => ({id,
quantity:1}));

// Performs the add-to-cart request with the prepared variants. const response = await fetch(window.Shopify.routes.root
+ "cart/add.js", { method: "POST", headers: { "Content-Type": "application/json", }, body: JSON.stringify({ items:
itemsToAdd }), });

if (!response.ok) { throw new Error("Network response was not ok."); }

console.log("ğŸš€ ~ Items added to cart");

// Fetching the updated cart data const cartResponse = await fetch(window.Shopify.routes.root +
"cart?section_id=api-cart-items"); const cartData = await cartResponse.json(); console.log("Cart updated:", cartData);

// Open the cart drawer const cartDrawerBtn =
document.querySelector("a.site-nav__link.site-nav__link--icon.cart-link.js-drawer-open-button-right"); if
(cartDrawerBtn) cartDrawerBtn.click();

} catch (error) { console.error("Error adding items to cart:", error); } });

function collectProductData() { const selectedVariants = document.querySelectorAll(".custom_select");

const productMap = new Map();

selectedVariants.forEach((variant) => { const productHandle = variant.dataset.product; const value = variant.value;

// If the product handle is already in the map, append the value to its options array if (productMap.has(productHandle))
{ const existingProduct = productMap.get(productHandle); existingProduct.options.push(value); } else { // Otherwise, add
a new entry for this product handle with the options initialized as an array with the value
productMap.set(productHandle, { product_handle: productHandle, options: [value], quantity: 1, }); } });

return Array.from(productMap.values()); }

async function matchProductsVariants(productData) { const fetchPromises = productData.map(async (product) => { const
response = await fetch(`${window.Shopify.routes.root}products/${product.product_handle}.js`); const productDetails =
await response.json(); return { product_handle: productDetails.handle, variants: productDetails.variants, }; });

const productsVariantsDetails = await Promise.all(fetchPromises);

const variantsMap = new Map(productsVariantsDetails.map(item => [item.product_handle, item.variants]));

const cartVariants = productData.flatMap((product) => { const variants = variantsMap.get(product.product_handle) || [];
return variants .filter(variant => JSON.stringify(variant.options) === JSON.stringify(product.options))
.map(matchingVariant => matchingVariant.id); });

return cartVariants; }
